{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport { GET_PROMISES, GET_PROMISE, GET_PROMISES_BY_CATEGORIES, GET_PROJECT_META } from \"./gql\";\nimport config from \"../../config\";\nimport promiseImage from \"../../assets/promise-thumb-01.png\";\nimport { slugify } from \"../../utils\";\nimport pc from \"../pc\";\nimport createApolloClient from \"./createApolloClient\";\nconst UNSPECIFIED_TEAM = \"unspecified\";\nconst CLIENT_PER_TEAM = new Map();\n\nfunction check({\n  team = undefined,\n  promiseStatuses = {},\n  initialState = {}\n}) {\n  const clientTeam = team || UNSPECIFIED_TEAM;\n  const existingClient = CLIENT_PER_TEAM.get(clientTeam);\n  const client = existingClient || createApolloClient(initialState, team);\n\n  if (!existingClient) {\n    CLIENT_PER_TEAM.set(clientTeam, existingClient);\n  }\n\n  function findItemByNodeLabel(tasks, label) {\n    return tasks.find(item => item.node.label === label);\n  }\n\n  function findItemByTaskLabel(items, label) {\n    return items.find(item => {\n      var _item$node$task;\n\n      return ((_item$node$task = item.node.task) === null || _item$node$task === void 0 ? void 0 : _item$node$task.label) === label;\n    });\n  }\n\n  function getAssetURL(filename, id) {\n    return `${config.CHECK_ASSET_URI}/${id}/${filename.replace(/ /g, \"_\")}`;\n  }\n\n  function getImage(node) {\n    var _node$log, _node$tasks, _imageLog$node;\n\n    const logs = (_node$log = node.log) === null || _node$log === void 0 ? void 0 : _node$log.edges;\n    const tasks = (_node$tasks = node.tasks) === null || _node$tasks === void 0 ? void 0 : _node$tasks.edges;\n    const imageLog = findItemByTaskLabel(logs, \"What is the image related to the promise\");\n    const imageTask = findItemByNodeLabel(tasks, \"What is the image related to the promise\");\n    const filename = imageTask.node.first_response_value;\n    let annotationChanges = {};\n\n    if (imageLog !== null && imageLog !== void 0 && (_imageLog$node = imageLog.node) !== null && _imageLog$node !== void 0 && _imageLog$node.object_changes_json) {\n      var _imageLog$node2;\n\n      annotationChanges = JSON.parse(imageLog === null || imageLog === void 0 ? void 0 : (_imageLog$node2 = imageLog.node) === null || _imageLog$node2 === void 0 ? void 0 : _imageLog$node2.object_changes_json).annotation_id;\n    }\n\n    const id = annotationChanges ? annotationChanges[1] : null; // latest image ID\n\n    return filename && id ? getAssetURL(filename, id) : promiseImage;\n  }\n\n  function getPromiseDate(node) {\n    var _node$tasks2;\n\n    const items = (_node$tasks2 = node.tasks) === null || _node$tasks2 === void 0 ? void 0 : _node$tasks2.edges;\n    const startDateTask = findItemByNodeLabel(items, \"When was this promise made?\");\n    return startDateTask ? startDateTask.node.first_response_value.split(\" \").slice(0, 3).join(\" \") : null;\n  }\n\n  async function getLinkedDataset(node) {\n    var _node$tasks3, _dataset$node, _dataset$node$first_r;\n\n    const items = (_node$tasks3 = node.tasks) === null || _node$tasks3 === void 0 ? void 0 : _node$tasks3.edges;\n    const dataset = findItemByNodeLabel(items, \"What data sets are linked to this promise?\");\n    const slug = (dataset === null || dataset === void 0 ? void 0 : (_dataset$node = dataset.node) === null || _dataset$node === void 0 ? void 0 : (_dataset$node$first_r = _dataset$node.first_response_value) === null || _dataset$node$first_r === void 0 ? void 0 : _dataset$node$first_r.split(\"/\")[-1]) || \"health-facilities-in-africa\"; // TODO: sample dataset name needs to be removed\n\n    const response = await fetch(`${config.CKAN_BACKEND_URL}/api/3/action/package_show?id=${slug}`);\n    const {\n      result\n    } = response.ok ? await response.json() : {\n      result: {}\n    };\n    return result;\n  }\n\n  function getChartLink(node) {\n    var _node$tasks4;\n\n    const items = (_node$tasks4 = node.tasks) === null || _node$tasks4 === void 0 ? void 0 : _node$tasks4.edges;\n    const chartTask = findItemByNodeLabel(items, \"What charts are related to this promise.\");\n    return chartTask ? chartTask.node.first_response_value : null;\n  }\n\n  function getPromiseDeadlineEvent(node) {\n    var _node$tasks5, _deadlineTask$node$fi;\n\n    const items = (_node$tasks5 = node.tasks) === null || _node$tasks5 === void 0 ? void 0 : _node$tasks5.edges;\n    const deadlineTask = findItemByNodeLabel(items, \"What is the deadline for the implementation of the promise?\");\n    const duration = Number(deadlineTask === null || deadlineTask === void 0 ? void 0 : (_deadlineTask$node$fi = deadlineTask.node.first_response_value) === null || _deadlineTask$node$fi === void 0 ? void 0 : _deadlineTask$node$fi.split(\"\")[0]);\n    const startYear = new Date(getPromiseDate(node)).getFullYear();\n    let deadlineEvent = {};\n\n    if (duration && startYear) {\n      deadlineEvent = {\n        title: \"Deadline\",\n        year: startYear + duration\n      };\n    }\n\n    return deadlineEvent;\n  }\n\n  function getStatusHistory(node) {\n    var _node$log2;\n\n    const logs = (_node$log2 = node.log) === null || _node$log2 === void 0 ? void 0 : _node$log2.edges;\n    const defaultStatus = promiseStatuses.find(status => status.title === \"Unrated\");\n    const statusLogs = logs.filter(item => {\n      var _item$node$task2;\n\n      return ((_item$node$task2 = item.node.task) === null || _item$node$task2 === void 0 ? void 0 : _item$node$task2.label) === \"What is the status of the promise?\";\n    });\n    const statusHistory = statusLogs.sort((statusA, statusB) => {\n      var _statusB$node, _statusA$node;\n\n      return (_statusB$node = statusB.node) === null || _statusB$node === void 0 ? void 0 : _statusB$node.created_at.localeCompare((_statusA$node = statusA.node) === null || _statusA$node === void 0 ? void 0 : _statusA$node.created_at);\n    }).filter((statusLog, idx) => {\n      var _statusLogs;\n\n      const currentStatus = JSON.parse(statusLog.node.object_changes_json).value[1].replace(/[^\\w\\s]/gi, \"\").trim();\n      const prevStatus = idx > 0 ? JSON.parse((_statusLogs = statusLogs[idx - 1]) === null || _statusLogs === void 0 ? void 0 : _statusLogs.node.object_changes_json).value[1].replace(/[^\\w\\s]/gi, \"\").trim() : null;\n      return prevStatus !== currentStatus;\n    }).map(statusLog => {\n      var _statusLog$node;\n\n      const date = ((_statusLog$node = statusLog.node) === null || _statusLog$node === void 0 ? void 0 : _statusLog$node.created_at) * 1000; // convert from secons to milliseconds\n\n      const status = JSON.parse(statusLog === null || statusLog === void 0 ? void 0 : statusLog.node.object_changes_json).value[1].replace(/[^\\w\\s]/gi, \"\").trim();\n      let matchingStatus = promiseStatuses.find(currentStatus => currentStatus.title === status);\n      matchingStatus = matchingStatus || defaultStatus;\n      return _objectSpread({\n        date\n      }, matchingStatus);\n    });\n    return statusHistory.length ? statusHistory : [defaultStatus];\n  }\n\n  async function getRelatedFactCheckUrls(node) {\n    var _node$tasks6, _relatedFactCheckTask;\n\n    const items = (_node$tasks6 = node.tasks) === null || _node$tasks6 === void 0 ? void 0 : _node$tasks6.edges;\n    const relatedFactCheckTasks = findItemByNodeLabel(items, \"What are the fact checks related to the promise?\");\n    const expression = /(https?:\\/\\/(?:www\\.|(?!www))[^\\s.]+\\.[^\\s]{2,}|www\\.[^\\s]+\\.[^\\s]{2,})/gi;\n    const matches = (relatedFactCheckTasks === null || relatedFactCheckTasks === void 0 ? void 0 : (_relatedFactCheckTask = relatedFactCheckTasks.node.first_response_value) === null || _relatedFactCheckTask === void 0 ? void 0 : _relatedFactCheckTask.match(expression)) || [];\n    const factCheckAPI = pc();\n    const relatedFactChecks = await factCheckAPI.factChecks({\n      urls: matches\n    }).list;\n    return relatedFactChecks || [];\n  }\n\n  async function getDataSource(node) {\n    var _node$tasks7;\n\n    const items = (_node$tasks7 = node.tasks) === null || _node$tasks7 === void 0 ? void 0 : _node$tasks7.edges;\n    const dataSourceTask = findItemByNodeLabel(items, \"Where was this promise documented?\");\n    const expression = /(https?:\\/\\/(?:www\\.|(?!www))[^\\s.]+\\.[^\\s]{2,}|www\\.[^\\s]+\\.[^\\s]{2,})/gi;\n    const matches = dataSourceTask.node.first_response_value.match(expression);\n    return Promise.all((matches === null || matches === void 0 ? void 0 : matches.map(async match => {\n      const result = await fetch(match.replace(\".html\", \".json\")); // get page number from url eg https://localhost#document/p16/a4\n\n      const pageNumber = Number(match.split(\"#document/\")[1].split(\"/\")[0].substring(1));\n      const document = await result.json();\n      return _objectSpread(_objectSpread({}, document), {}, {\n        pageNumber,\n        dataSourceUrl: match\n      });\n    })) || []);\n  }\n\n  async function nodeToPromise(node) {\n    var _node$tags, _node$tags$edges;\n\n    const id = node.dbid;\n    const slug = slugify(node.title);\n    return {\n      id,\n      href: `/promises/${id}/${slug}`,\n      slug,\n      title: node.title,\n      image: getImage(node),\n      description: node.description,\n      chartLinks: getChartLink(node),\n      date: getPromiseDate(node),\n      events: [getPromiseDeadlineEvent(node)],\n      status: getStatusHistory(node)[0],\n      statusHistory: getStatusHistory(node),\n      documents: await (getDataSource(node) || []),\n      relatedFactChecks: await (getRelatedFactCheckUrls(node) || []),\n      tags: (node === null || node === void 0 ? void 0 : (_node$tags = node.tags) === null || _node$tags === void 0 ? void 0 : (_node$tags$edges = _node$tags.edges) === null || _node$tags$edges === void 0 ? void 0 : _node$tags$edges.map(({\n        node: {\n          tag_text: text\n        }\n      }) => text)) || []\n    };\n  }\n\n  async function handlePromisesResult(res) {\n    var _res$data, _res$data$search, _res$data$search$medi;\n\n    return Promise.all((res === null || res === void 0 ? void 0 : (_res$data = res.data) === null || _res$data === void 0 ? void 0 : (_res$data$search = _res$data.search) === null || _res$data$search === void 0 ? void 0 : (_res$data$search$medi = _res$data$search.medias) === null || _res$data$search$medi === void 0 ? void 0 : _res$data$search$medi.edges.map(({\n      node\n    }) => nodeToPromise(node))) || []);\n  }\n\n  async function handleSinglePromise({\n    data\n  }) {\n    const node = data === null || data === void 0 ? void 0 : data.project_media;\n\n    if (node) {\n      var _data$search, _data$search$medias;\n\n      const dataset = await (getLinkedDataset(node) || {});\n      const singlePromise = await nodeToPromise(node);\n      const otherPromises = await Promise.all((data === null || data === void 0 ? void 0 : (_data$search = data.search) === null || _data$search === void 0 ? void 0 : (_data$search$medias = _data$search.medias) === null || _data$search$medias === void 0 ? void 0 : _data$search$medias.edges.map(({\n        node: n\n      }) => nodeToPromise(n))) || []);\n      const relatedPromises = otherPromises.filter(p => p.id !== singlePromise.id && singlePromise.tags.some(v => p.tags.includes(v)));\n      return _objectSpread(_objectSpread({}, singlePromise), {}, {\n        dataset,\n        relatedPromises: relatedPromises.slice(0, 3)\n      });\n    }\n\n    return null;\n  }\n\n  function handleMeta({\n    data: {\n      me: {\n        current_team: {\n          updated_at: updatedAt,\n          description,\n          tag_texts: tags\n        }\n      }\n    }\n  }) {\n    const descriptionArr = description.split(\"|\");\n    const position = descriptionArr[2];\n    const updatedAtLabel = descriptionArr[3];\n    const promiseLabel = descriptionArr[4];\n    const trailText = descriptionArr[5];\n    return {\n      updatedAt: Number(updatedAt) * 1000,\n      description: descriptionArr[0],\n      position,\n      promiseLabel,\n      trailText,\n      updatedAtLabel,\n      name: descriptionArr[1],\n      tags: tags.edges.map(tag => tag.node)\n    };\n  }\n\n  function handlePromisesCategoryResults({\n    data\n  }) {\n    return {\n      id: data.team.id,\n      count: data.team.medias_count,\n      name: data.team.name,\n      categories: data.team.projects.edges.map(({\n        node\n      }) => ({\n        id: node.id,\n        title: node.title,\n        count: node.medias_count,\n        projects: node.project_medias.edges.map(promise => promise.node)\n      }))\n    };\n  }\n\n  const api = {\n    promises: async variables => {\n      return client.query({\n        query: GET_PROMISES,\n        variables\n      }).then(handlePromisesResult).then(response => {\n        return response;\n      });\n    },\n    promisesByCategories: async variables => {\n      return client.query({\n        query: GET_PROMISES_BY_CATEGORIES,\n        variables\n      }).then(handlePromisesCategoryResults).then(promise => promise);\n    },\n    projectMeta: async () => {\n      return client.query({\n        query: GET_PROJECT_META\n      }).then(handleMeta);\n    },\n    promise: async variables => {\n      return client.query({\n        query: GET_PROMISE,\n        variables\n      }).then(handleSinglePromise);\n    }\n  };\n  return api;\n}\n\nexport default check;","map":{"version":3,"sources":["/Users/cfafrica/Desktop/vercel-monorepo-setup/apps/promiseTracker/src/lib/check/index.js"],"names":["GET_PROMISES","GET_PROMISE","GET_PROMISES_BY_CATEGORIES","GET_PROJECT_META","config","promiseImage","slugify","pc","createApolloClient","UNSPECIFIED_TEAM","CLIENT_PER_TEAM","Map","check","team","undefined","promiseStatuses","initialState","clientTeam","existingClient","get","client","set","findItemByNodeLabel","tasks","label","find","item","node","findItemByTaskLabel","items","task","getAssetURL","filename","id","CHECK_ASSET_URI","replace","getImage","logs","log","edges","imageLog","imageTask","first_response_value","annotationChanges","object_changes_json","JSON","parse","annotation_id","getPromiseDate","startDateTask","split","slice","join","getLinkedDataset","dataset","slug","response","fetch","CKAN_BACKEND_URL","result","ok","json","getChartLink","chartTask","getPromiseDeadlineEvent","deadlineTask","duration","Number","startYear","Date","getFullYear","deadlineEvent","title","year","getStatusHistory","defaultStatus","status","statusLogs","filter","statusHistory","sort","statusA","statusB","created_at","localeCompare","statusLog","idx","currentStatus","value","trim","prevStatus","map","date","matchingStatus","length","getRelatedFactCheckUrls","relatedFactCheckTasks","expression","matches","match","factCheckAPI","relatedFactChecks","factChecks","urls","list","getDataSource","dataSourceTask","Promise","all","pageNumber","substring","document","dataSourceUrl","nodeToPromise","dbid","href","image","description","chartLinks","events","documents","tags","tag_text","text","handlePromisesResult","res","data","search","medias","handleSinglePromise","project_media","singlePromise","otherPromises","n","relatedPromises","p","some","v","includes","handleMeta","me","current_team","updated_at","updatedAt","tag_texts","descriptionArr","position","updatedAtLabel","promiseLabel","trailText","name","tag","handlePromisesCategoryResults","count","medias_count","categories","projects","project_medias","promise","api","promises","variables","query","then","promisesByCategories","projectMeta"],"mappings":"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","sourcesContent":["import {\n  GET_PROMISES,\n  GET_PROMISE,\n  GET_PROMISES_BY_CATEGORIES,\n  GET_PROJECT_META,\n} from \"@/promisetracker/lib/check/gql\";\n\nimport config from \"@/promisetracker/config\";\nimport promiseImage from \"@/promisetracker/assets/promise-thumb-01.png\";\nimport { slugify } from \"@/promisetracker/utils\";\nimport pc from \"@/promisetracker/lib/pc\";\nimport createApolloClient from \"./createApolloClient\";\n\nconst UNSPECIFIED_TEAM = \"unspecified\";\nconst CLIENT_PER_TEAM = new Map();\n\nfunction check({ team = undefined, promiseStatuses = {}, initialState = {} }) {\n  const clientTeam = team || UNSPECIFIED_TEAM;\n  const existingClient = CLIENT_PER_TEAM.get(clientTeam);\n  const client = existingClient || createApolloClient(initialState, team);\n  if (!existingClient) {\n    CLIENT_PER_TEAM.set(clientTeam, existingClient);\n  }\n\n  function findItemByNodeLabel(tasks, label) {\n    return tasks.find((item) => item.node.label === label);\n  }\n\n  function findItemByTaskLabel(items, label) {\n    return items.find((item) => item.node.task?.label === label);\n  }\n\n  function getAssetURL(filename, id) {\n    return `${config.CHECK_ASSET_URI}/${id}/${filename.replace(/ /g, \"_\")}`;\n  }\n\n  function getImage(node) {\n    const logs = node.log?.edges;\n    const tasks = node.tasks?.edges;\n    const imageLog = findItemByTaskLabel(\n      logs,\n      \"What is the image related to the promise\"\n    );\n    const imageTask = findItemByNodeLabel(\n      tasks,\n      \"What is the image related to the promise\"\n    );\n    const filename = imageTask.node.first_response_value;\n    let annotationChanges = {};\n    if (imageLog?.node?.object_changes_json) {\n      annotationChanges = JSON.parse(imageLog?.node?.object_changes_json)\n        .annotation_id;\n    }\n    const id = annotationChanges ? annotationChanges[1] : null; // latest image ID\n    return filename && id ? getAssetURL(filename, id) : promiseImage;\n  }\n\n  function getPromiseDate(node) {\n    const items = node.tasks?.edges;\n    const startDateTask = findItemByNodeLabel(\n      items,\n      \"When was this promise made?\"\n    );\n    return startDateTask\n      ? startDateTask.node.first_response_value.split(\" \").slice(0, 3).join(\" \")\n      : null;\n  }\n\n  async function getLinkedDataset(node) {\n    const items = node.tasks?.edges;\n    const dataset = findItemByNodeLabel(\n      items,\n      \"What data sets are linked to this promise?\"\n    );\n    const slug =\n      dataset?.node?.first_response_value?.split(\"/\")[-1] ||\n      \"health-facilities-in-africa\"; // TODO: sample dataset name needs to be removed\n    const response = await fetch(\n      `${config.CKAN_BACKEND_URL}/api/3/action/package_show?id=${slug}`\n    );\n    const { result } = response.ok ? await response.json() : { result: {} };\n    return result;\n  }\n\n  function getChartLink(node) {\n    const items = node.tasks?.edges;\n    const chartTask = findItemByNodeLabel(\n      items,\n      \"What charts are related to this promise.\"\n    );\n    return chartTask ? chartTask.node.first_response_value : null;\n  }\n\n  function getPromiseDeadlineEvent(node) {\n    const items = node.tasks?.edges;\n    const deadlineTask = findItemByNodeLabel(\n      items,\n      \"What is the deadline for the implementation of the promise?\"\n    );\n    const duration = Number(\n      deadlineTask?.node.first_response_value?.split(\"\")[0]\n    );\n    const startYear = new Date(getPromiseDate(node)).getFullYear();\n\n    let deadlineEvent = {};\n\n    if (duration && startYear) {\n      deadlineEvent = {\n        title: \"Deadline\",\n        year: startYear + duration,\n      };\n    }\n    return deadlineEvent;\n  }\n\n  function getStatusHistory(node) {\n    const logs = node.log?.edges;\n    const defaultStatus = promiseStatuses.find(\n      (status) => status.title === \"Unrated\"\n    );\n    const statusLogs = logs.filter(\n      (item) => item.node.task?.label === \"What is the status of the promise?\"\n    );\n    const statusHistory = statusLogs\n      .sort((statusA, statusB) =>\n        statusB.node?.created_at.localeCompare(statusA.node?.created_at)\n      )\n      .filter((statusLog, idx) => {\n        const currentStatus = JSON.parse(statusLog.node.object_changes_json)\n          .value[1].replace(/[^\\w\\s]/gi, \"\")\n          .trim();\n        const prevStatus =\n          idx > 0\n            ? JSON.parse(statusLogs[idx - 1]?.node.object_changes_json)\n                .value[1].replace(/[^\\w\\s]/gi, \"\")\n                .trim()\n            : null;\n        return prevStatus !== currentStatus;\n      })\n      .map((statusLog) => {\n        const date = statusLog.node?.created_at * 1000; // convert from secons to milliseconds\n        const status = JSON.parse(statusLog?.node.object_changes_json)\n          .value[1].replace(/[^\\w\\s]/gi, \"\")\n          .trim();\n        let matchingStatus = promiseStatuses.find(\n          (currentStatus) => currentStatus.title === status\n        );\n        matchingStatus = matchingStatus || defaultStatus;\n        return { date, ...matchingStatus };\n      });\n\n    return statusHistory.length ? statusHistory : [defaultStatus];\n  }\n  async function getRelatedFactCheckUrls(node) {\n    const items = node.tasks?.edges;\n    const relatedFactCheckTasks = findItemByNodeLabel(\n      items,\n      \"What are the fact checks related to the promise?\"\n    );\n    const expression = /(https?:\\/\\/(?:www\\.|(?!www))[^\\s.]+\\.[^\\s]{2,}|www\\.[^\\s]+\\.[^\\s]{2,})/gi;\n    const matches =\n      relatedFactCheckTasks?.node.first_response_value?.match(expression) || [];\n    const factCheckAPI = pc();\n    const relatedFactChecks = await factCheckAPI.factChecks({ urls: matches })\n      .list;\n    return relatedFactChecks || [];\n  }\n\n  async function getDataSource(node) {\n    const items = node.tasks?.edges;\n    const dataSourceTask = findItemByNodeLabel(\n      items,\n      \"Where was this promise documented?\"\n    );\n\n    const expression = /(https?:\\/\\/(?:www\\.|(?!www))[^\\s.]+\\.[^\\s]{2,}|www\\.[^\\s]+\\.[^\\s]{2,})/gi;\n    const matches = dataSourceTask.node.first_response_value.match(expression);\n    return Promise.all(\n      matches?.map(async (match) => {\n        const result = await fetch(match.replace(\".html\", \".json\"));\n        // get page number from url eg https://localhost#document/p16/a4\n        const pageNumber = Number(\n          match.split(\"#document/\")[1].split(\"/\")[0].substring(1)\n        );\n        const document = await result.json();\n        return { ...document, pageNumber, dataSourceUrl: match };\n      }) || []\n    );\n  }\n\n  async function nodeToPromise(node) {\n    const id = node.dbid;\n    const slug = slugify(node.title);\n\n    return {\n      id,\n      href: `/promises/${id}/${slug}`,\n      slug,\n      title: node.title,\n      image: getImage(node),\n      description: node.description,\n      chartLinks: getChartLink(node),\n      date: getPromiseDate(node),\n      events: [getPromiseDeadlineEvent(node)],\n      status: getStatusHistory(node)[0],\n      statusHistory: getStatusHistory(node),\n      documents: await (getDataSource(node) || []),\n      relatedFactChecks: await (getRelatedFactCheckUrls(node) || []),\n      tags:\n        node?.tags?.edges?.map(({ node: { tag_text: text } }) => text) || [],\n    };\n  }\n\n  async function handlePromisesResult(res) {\n    return Promise.all(\n      res?.data?.search?.medias?.edges.map(({ node }) => nodeToPromise(node)) ||\n        []\n    );\n  }\n\n  async function handleSinglePromise({ data }) {\n    const node = data?.project_media;\n\n    if (node) {\n      const dataset = await (getLinkedDataset(node) || {});\n      const singlePromise = await nodeToPromise(node);\n      const otherPromises = await Promise.all(\n        data?.search?.medias?.edges.map(({ node: n }) => nodeToPromise(n)) || []\n      );\n      const relatedPromises = otherPromises.filter(\n        (p) =>\n          p.id !== singlePromise.id &&\n          singlePromise.tags.some((v) => p.tags.includes(v))\n      );\n\n      return {\n        ...singlePromise,\n        dataset,\n        relatedPromises: relatedPromises.slice(0, 3),\n      };\n    }\n    return null;\n  }\n\n  function handleMeta({\n    data: {\n      me: {\n        current_team: { updated_at: updatedAt, description, tag_texts: tags },\n      },\n    },\n  }) {\n    const descriptionArr = description.split(\"|\");\n    const position = descriptionArr[2];\n    const updatedAtLabel = descriptionArr[3];\n    const promiseLabel = descriptionArr[4];\n    const trailText = descriptionArr[5];\n    return {\n      updatedAt: Number(updatedAt) * 1000,\n      description: descriptionArr[0],\n      position,\n      promiseLabel,\n      trailText,\n      updatedAtLabel,\n      name: descriptionArr[1],\n      tags: tags.edges.map((tag) => tag.node),\n    };\n  }\n\n  function handlePromisesCategoryResults({ data }) {\n    return {\n      id: data.team.id,\n      count: data.team.medias_count,\n      name: data.team.name,\n      categories: data.team.projects.edges.map(({ node }) => ({\n        id: node.id,\n        title: node.title,\n        count: node.medias_count,\n        projects: node.project_medias.edges.map((promise) => promise.node),\n      })),\n    };\n  }\n\n  const api = {\n    promises: async (variables) => {\n      return client\n        .query({ query: GET_PROMISES, variables })\n        .then(handlePromisesResult)\n        .then((response) => {\n          return response;\n        });\n    },\n    promisesByCategories: async (variables) => {\n      return client\n        .query({ query: GET_PROMISES_BY_CATEGORIES, variables })\n        .then(handlePromisesCategoryResults)\n        .then((promise) => promise);\n    },\n    projectMeta: async () => {\n      return client.query({ query: GET_PROJECT_META }).then(handleMeta);\n    },\n    promise: async (variables) => {\n      return client\n        .query({ query: GET_PROMISE, variables })\n        .then(handleSinglePromise);\n    },\n  };\n  return api;\n}\n\nexport default check;\n"]},"metadata":{},"sourceType":"module"}